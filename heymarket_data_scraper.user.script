// ==UserScript==
// @name         Heymarket Data Scraper
// @namespace    http://tampermonkey.net/
// @version      5.0
// @description  Scrapes Heymarket list and conversation data and sends it to Google Sheets with seamless redirect-based Google OAuth authentication.
// @match        https://app.heymarket.com/*
// @grant        GM_xmlhttpRequest
// @grant        GM_getValue
// @grant        GM_setValue
// @grant        GM_download
// @grant        window.close
// @grant        window.focus
// @connect      api-prod-client.heymarket.com
// @connect      script.google.com
// @connect      script.googleusercontent.com
// @connect      *.google.com
// @connect      *.googleusercontent.com
// @connect      accounts.google.com
// @connect      oauth2.googleapis.com
// @run-at       document-start
// ==/UserScript==

// ‚ö° CRITICAL: Intercept network requests IMMEDIATELY before anything else
let SECURITY_TOKEN = null;

// Intercept fetch requests at the very start
(function() {
    const originalFetch = window.fetch;
    window.fetch = function(...args) {
        const [url, options] = args;
        
        // Check if this is a Heymarket API request
        if (url && typeof url === 'string' && url.includes('api-prod-client.heymarket.com')) {
            // Extract token from request headers
            if (options && options.headers) {
                const headers = options.headers;
                const token = headers['x-emb-security-token'] || headers['X-Emb-Security-Token'] || 
                             headers['x-emb-security-token'.toLowerCase()] || headers['X-EMB-SECURITY-TOKEN'];
                if (token && !SECURITY_TOKEN) {
                    SECURITY_TOKEN = token;
                    console.log('üéØ Security token intercepted from fetch:', token.substring(0, 20) + '...');
                }
            }
        }
        
        return originalFetch.apply(this, args);
    };
})();

// Intercept XMLHttpRequest at the very start
(function() {
    const originalOpen = XMLHttpRequest.prototype.open;
    const originalSetRequestHeader = XMLHttpRequest.prototype.setRequestHeader;
    const originalSend = XMLHttpRequest.prototype.send;
    
    XMLHttpRequest.prototype.setRequestHeader = function(header, value) {
        if (header && header.toLowerCase() === 'x-emb-security-token' && !SECURITY_TOKEN) {
            SECURITY_TOKEN = value;
            console.log('üéØ Security token intercepted from XHR:', value.substring(0, 20) + '...');
        }
        return originalSetRequestHeader.apply(this, arguments);
    };
    
    // Also intercept the send method to catch any late headers
    XMLHttpRequest.prototype.send = function(data) {
        // Check if URL is Heymarket API
        if (this._url && this._url.includes('api-prod-client.heymarket.com')) {
            console.log('üì° Heymarket API request detected:', this._url);
        }
        return originalSend.apply(this, arguments);
    };
    
    XMLHttpRequest.prototype.open = function(method, url, ...args) {
        this._url = url; // Store URL for later reference
        return originalOpen.apply(this, arguments);
    };
})();

// Also try to intercept any existing tokens from global objects
(function checkGlobalToken() {
    // Try multiple times in case objects load later
    let attempts = 0;
    const maxAttempts = 50;
    
    function searchForToken() {
        attempts++;
        
        // Check various global objects for tokens
        const searchTargets = [
            window.localStorage,
            window.sessionStorage,
            window.__NUXT__,
            window.__INITIAL_STATE__,
            window.APP_CONFIG,
            window.authConfig,
            window.apiConfig
        ];
        
        for (const target of searchTargets) {
            if (target && typeof target === 'object') {
                const str = JSON.stringify(target);
                const tokenMatch = str.match(/[a-zA-Z0-9]{40,}/g);
                if (tokenMatch && !SECURITY_TOKEN) {
                    // Look for likely security tokens (long alphanumeric strings)
                    for (const match of tokenMatch) {
                        if (match.length >= 40 && /^[a-zA-Z0-9]+$/.test(match)) {
                            SECURITY_TOKEN = match;
                            console.log('üîç Potential security token found in global object:', match.substring(0, 20) + '...');
                            return;
                        }
                    }
                }
            }
        }
        
        if (attempts < maxAttempts && !SECURITY_TOKEN) {
            setTimeout(searchForToken, 100);
        }
    }
    
    // Start searching immediately and then periodically
    searchForToken();
})();

(function() {
    'use strict';

    const TEAM_ID = 64149;
    const MAX_CONVERSATION_MESSAGES = 20;
    const GOOGLE_SCRIPT_ID = "AKfycbzfOem8exv5LUzaHPHjBbizCFEl4Mx700YLg4XgWwIqsOP1BwUMvyxdim2w2iEdMvYF";

    // Google Apps Script configuration
    const GOOGLE_APPS_SCRIPT_URL = "https://script.google.com/macros/s/" + GOOGLE_SCRIPT_ID + "/exec";

    // Google OAuth configuration
    const GOOGLE_CLIENT_ID = "221842260905-nidbveovs3vjft1oc42rf4a3aeamdafo.apps.googleusercontent.com";

    // OAuth token management with Tampermonkey storage
    function getStoredToken() {
        return GM_getValue('google_oauth_token', null);
    }

    function setStoredToken(token) {
        GM_setValue('google_oauth_token', token);
    }

    function clearStoredToken() {
        GM_setValue('google_oauth_token', null);
    }

    async function promptForOAuthToken() {
        const savedToken = getStoredToken();
        
        if (savedToken) {
            // Try to validate the saved token first
            const isValid = await validateToken(savedToken);
            if (isValid) {
                console.log('‚úÖ Using saved OAuth token');
                return savedToken;
            } else {
                console.log('‚ùå Saved token is invalid, clearing it');
                clearStoredToken();
            }
        }
        
        // Start Google OAuth flow
        console.log('üîê Starting Google OAuth authentication...');
        const token = await authenticateWithGoogle();
        
        if (token) {
            const isValid = await validateToken(token);
            if (isValid) {
                setStoredToken(token);
                console.log('‚úÖ OAuth authentication successful');
                return token;
            } else {
                alert('‚ùå Authentication failed. Please try again.');
                return null;
            }
        }
        
        return null;
    }

    async function authenticateWithGoogle() {
        return new Promise((resolve, reject) => {
            // Create a special auth URL that will handle the OAuth flow and return to Heymarket
            const currentUrl = window.location.href;
            const state = Math.random().toString(36).substring(2, 15);
            
            // Store the callback info for when we return
            GM_setValue('auth_state', state);
            GM_setValue('auth_callback', 'pending');
            GM_setValue('return_url', currentUrl);
            
            // Build OAuth URL that redirects to our auth page
            const authUrl = new URL('https://galygious.github.io/SMP_Broadcast_Reports_Test/');
            authUrl.searchParams.append('userscript_auth', 'true');
            authUrl.searchParams.append('state', state);
            authUrl.searchParams.append('return_url', encodeURIComponent(currentUrl));
            
            console.log('üîê Redirecting to Google authentication...');
            
            // Show user what's happening
            const shouldProceed = confirm(`üîê Google Authentication Required

This will redirect you to sign in with Google and then return you back to this page.

Click OK to proceed with authentication.`);

            if (!shouldProceed) {
                reject(new Error('Authentication cancelled by user'));
                return;
            }

            // Set up a listener for when we return
            const checkInterval = setInterval(() => {
                const authResult = GM_getValue('auth_callback', 'pending');
                if (authResult !== 'pending') {
                    clearInterval(checkInterval);
                    
                    if (authResult && authResult.startsWith('eyJ')) {
                        // Success! We got a token
                        GM_setValue('auth_callback', 'pending'); // Reset for next time
                        console.log('‚úÖ Authentication successful');
                        resolve(authResult);
                    } else {
                        // Error or cancellation
                        console.log('‚ùå Authentication failed');
                        reject(new Error('Authentication failed or cancelled'));
                    }
                }
            }, 1000);

            // Redirect to auth page
            window.location.href = authUrl.toString();
        });
    }

    // Check if we're returning from authentication
    function checkForAuthReturn() {
        const urlParams = new URLSearchParams(window.location.search);
        const isAuthReturn = urlParams.get('userscript_auth_return');
        const token = urlParams.get('token');
        const state = urlParams.get('state');
        
        if (isAuthReturn && token && state) {
            const expectedState = GM_getValue('auth_state', '');
            
            if (state === expectedState) {
                // Valid auth return - store the token
                console.log('‚úÖ Auth return detected, storing token');
                GM_setValue('auth_callback', token);
                
                // Clean up URL parameters
                const cleanUrl = window.location.href.split('?')[0];
                window.history.replaceState({}, document.title, cleanUrl);
                
                return true;
            } else {
                console.log('‚ùå Invalid auth state');
                GM_setValue('auth_callback', 'error');
            }
        }
        
        return false;
    }



    async function validateToken(token) {
        try {
            // Quick validation by trying to verify access
            const response = await new Promise((resolve, reject) => {
                GM_xmlhttpRequest({
                    method: 'POST',
                    url: GOOGLE_APPS_SCRIPT_URL,
                    headers: {
                        'Content-Type': 'text/plain;charset=utf-8'
                    },
                    data: JSON.stringify({
                        userToken: token,
                        action: 'verifyAccess'
                    }),
                    onload: (resp) => resolve(JSON.parse(resp.responseText)),
                    onerror: reject
                });
            });
            
            return response.ok === true;
        } catch (error) {
            console.error('Token validation error:', error);
            return false;
        }
    }



    function extractSecurityToken() {
        // Method 1: Try to find token in localStorage
        try {
            const heymarketData = localStorage.getItem('heymarket') || localStorage.getItem('auth') || localStorage.getItem('token');
            if (heymarketData) {
                const parsed = JSON.parse(heymarketData);
                if (parsed.token || parsed.security_token || parsed.authToken) {
                    return parsed.token || parsed.security_token || parsed.authToken;
                }
            }
        } catch (e) {
            console.log("Could not extract token from localStorage:", e);
        }

        // Method 2: Try to find token in sessionStorage
        try {
            const sessionData = sessionStorage.getItem('heymarket') || sessionStorage.getItem('auth') || sessionStorage.getItem('token');
            if (sessionData) {
                const parsed = JSON.parse(sessionData);
                if (parsed.token || parsed.security_token || parsed.authToken) {
                    return parsed.token || parsed.security_token || parsed.authToken;
                }
            }
        } catch (e) {
            console.log("Could not extract token from sessionStorage:", e);
        }

        // Method 3: Try to extract from global window objects
        try {
            if (window.heymarket && window.heymarket.token) {
                return window.heymarket.token;
            }
            if (window.app && window.app.token) {
                return window.app.token;
            }
            if (window.auth && window.auth.token) {
                return window.auth.token;
            }
        } catch (e) {
            console.log("Could not extract token from window objects:", e);
        }

        // Method 4: Try to find in page's script tags or meta tags
        try {
            const scripts = document.querySelectorAll('script');
            for (let script of scripts) {
                if (script.textContent.includes('security-token') || script.textContent.includes('auth-token')) {
                    const tokenMatch = script.textContent.match(/["']([A-Za-z0-9+/=]{30,})["']/);
                    if (tokenMatch) {
                        return tokenMatch[1];
                    }
                }
            }
        } catch (e) {
            console.log("Could not extract token from scripts:", e);
        }

        // Method 5: Try to inspect network requests (last resort)
        console.warn("Could not extract security token from storage or scripts.");
        console.log("üí° To manually get the token:");
        console.log("1. Open DevTools (F12) ‚Üí Network tab");
        console.log("2. Perform any action in Heymarket (like viewing a contact)");
        console.log("3. Look for requests to api-prod-client.heymarket.com");
        console.log("4. Check request headers for 'x-emb-security-token'");
        console.log("5. Copy that value and update the userscript");
        
        return null;
    }

    async function checkIfDateAlreadyExported(sheetDate, userToken) {
        try {
            console.log(`Checking if data for ${sheetDate} has already been exported...`);

            const response = await new Promise((resolve, reject) => {
                GM_xmlhttpRequest({
                    method: 'POST',
                    url: GOOGLE_APPS_SCRIPT_URL,
                    headers: {
                        'Content-Type': 'text/plain;charset=utf-8'
                    },
                    data: JSON.stringify({
                        userToken: userToken,
                        action: 'getSheetNames'
                    }),
                    onload: (response) => {
                        if (response.status === 200) {
                            try {
                                const result = JSON.parse(response.responseText);
                                resolve(result);
                            } catch (e) {
                                reject(new Error("Failed to parse response from Google Apps Script"));
                            }
                        } else {
                            reject(new Error(`Google Apps Script request failed with status: ${response.status}`));
                        }
                    },
                    onerror: (error) => {
                        reject(new Error(`Network error when checking sheets: ${error.statusText}`));
                    }
                });
            });

            // Check if any sheet name starts with the broadcast date
            const sheetNames = response.sheetNames || [];
            return sheetNames.some(name => name.startsWith(sheetDate));
        } catch (error) {
            console.warn("Could not check existing sheets:", error);
            return false; // Continue with export if check fails
        }
    }

    // Mapping of inbox_id to brand name
    const BRAND_MAP = {
        '80071': 'BOOKING',
        '80158': 'SCHEDULE',
        '80157': 'RESERVE',
        '80159': 'SESSIONS'
    };

    let allData = [];
    let listData = [];
    let processedLists = new Set();
    let totalReportsToProcess = 0;
    let reportsProcessed = 0;

    function formatPhoneNumber(number) {
        // Remove leading '1' and format as ' (XXX) XXX-XXXX'
        const cleaned = ('' + number).replace(/\D/g, '');
        const match = cleaned.match(/^(\d{1})(\d{3})(\d{3})(\d{4})$/);
        if (match) {
            return `1 (${match[2]}) ${match[3]}-${match[4]}`;
        }
        return number;
    }

    // A simple CSV utility
    function arrayToCSV(data, headers) {
        let csvContent = "";
        if (headers) {
            csvContent += headers.join(",") + "\n";
        }
        data.forEach(row => {
            let rowString = row.map(cell => {
                if (typeof cell === 'string') {
                    // Escape double quotes and enclose in double quotes
                    return `"${cell.replace(/"/g, '""')}"`;
                }
                return cell;
            }).join(",");
            csvContent += rowString + "\n";
        });
        return csvContent;
    }

    async function sendToGoogleSheets(userToken, sheetDate) {
        if (allData.length === 0) {
            console.log("No data to send to Google Sheets.");
            return;
        }

        // Prepare headers
        const headers = ["Brand", "Fname", "Lname", "Number", "Initial Send Time", "Failed", "Response", "Response Time (Central)"];
        for (let i = 1; i <= MAX_CONVERSATION_MESSAGES; i++) {
            headers.push(`Message ${i}`);
        }

        // Create 2D array for Google Sheets (headers + data)
        const values = [headers, ...allData];

        try {
            console.log("Sending data to Google Sheets...");

            // Use GM_xmlhttpRequest for the POST request
            const response = await new Promise((resolve, reject) => {
                GM_xmlhttpRequest({
                    method: 'POST',
                    url: GOOGLE_APPS_SCRIPT_URL,
                    headers: {
                        'Content-Type': 'text/plain;charset=utf-8'
                    },
                    data: JSON.stringify({
                        userToken: userToken,
                        action: 'appendData',
                        sheetDate: sheetDate,
                        values: values
                    }),
                    onload: (response) => {
                        console.log("Google Apps Script response status:", response.status);
                        console.log("Google Apps Script response:", response.responseText);
                        
                        if (response.status === 200) {
                            try {
                                const result = JSON.parse(response.responseText);
                                resolve(result);
                            } catch (e) {
                                console.error("Failed to parse Google Apps Script response:", response.responseText);
                                reject(new Error("Failed to parse response from Google Apps Script"));
                            }
                        } else {
                            console.error("Google Apps Script error response:", response.responseText);
                            reject(new Error(`Google Apps Script request failed with status: ${response.status} - ${response.responseText}`));
                        }
                    },
                    onerror: (error) => {
                        reject(new Error(`Network error when sending to Google Sheets: ${error.statusText}`));
                    }
                });
            });

            if (response.ok) {
                console.log(`‚úÖ Data successfully sent to Google Sheets! Sheet name: ${response.sheetName}`);
                console.log(`üìä Sent ${allData.length} rows of data to Google Sheets`);

                // Show success message to user
                alert(`Success! Data for ${sheetDate} sent to Google Sheets.\nSheet: ${response.sheetName}\nRows: ${allData.length}`);
            } else {
                throw new Error("Google Apps Script returned error response");
            }
        } catch (error) {
            console.error("‚ùå Failed to send data to Google Sheets:", error);
            alert(`Failed to send data to Google Sheets: ${error.message}`);

            // Fallback: still offer CSV download
            console.log("Offering CSV download as fallback...");
            downloadCSVFallback();
        }
    }

    function downloadCSVFallback() {
        if (allData.length === 0) {
            console.log("No data to download.");
            return;
        }

        const headers = ["Brand", "Fname", "Lname", "Number", "Initial Send Time", "Failed", "Response", "Response Time (Central)"];
        for (let i = 1; i <= MAX_CONVERSATION_MESSAGES; i++) {
            headers.push(`Message ${i}`);
        }

        const csv = arrayToCSV(allData, headers);
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.setAttribute("href", url);
        link.setAttribute("download", "heymarket_data_fallback.csv");
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        console.log("Fallback CSV download initiated.");
    }

    async function fetchWithToken(url, options) {
        options.headers = options.headers || {};
        options.headers['x-emb-security-token'] = SECURITY_TOKEN;
        options.headers['content-type'] = 'application/json;charset=UTF-8';
        options.method = options.method || 'POST';

        // Use GM_xmlhttpRequest for cross-origin requests
        return new Promise((resolve, reject) => {
            GM_xmlhttpRequest({
                method: options.method,
                url: url,
                headers: options.headers,
                data: options.body,
                onload: (response) => {
                    if (response.status === 200) {
                        try {
                            const json = JSON.parse(response.responseText);
                            resolve(json);
                        } catch (e) {
                            reject(new Error("Failed to parse JSON response."));
                        }
                    } else {
                        reject(new Error(`Request failed with status: ${response.status}`));
                    }
                },
                onerror: (error) => {
                    reject(new Error(`Network error: ${error.statusText}`));
                }
            });
        });
    }

    async function fetchLists() {
        // Try to use intercepted token first, then fall back to extraction
        if (!SECURITY_TOKEN) {
            console.log("üîç No token intercepted yet, trying manual extraction...");
            SECURITY_TOKEN = extractSecurityToken();
        }
        
        if (!SECURITY_TOKEN) {
            alert("‚ùå Could not extract security token from Heymarket session.\n\nPlease:\n1. Make sure you're logged into Heymarket\n2. Navigate around the Heymarket interface to trigger some API calls\n3. Refresh the page if needed\n4. Try running the script again");
            return;
        }
        console.log("‚úÖ Security token available:", SECURITY_TOKEN.substring(0, 20) + '...');

        // Get OAuth token from secure storage
        const userToken = await promptForOAuthToken();
        if (!userToken) {
            alert("‚ùå OAuth token is required to save data to Google Sheets.");
            return;
        }

        // We'll check for existing data after we determine the broadcast date
        // This happens in fetchBroadcasts() now

        console.log("Fetching lists...");
        const url = "https://api-prod-client.heymarket.com/v4/lists/fetch";
        const body = {
            filter: "MY",
            archived: false,
            ascending: false,
            order: "updated",
            team_id: TEAM_ID,
            type: "lists",
            resetLocalList: true,
            date: new Date().toISOString()
        };

        try {
            const response = await fetchWithToken(url, { body: JSON.stringify(body) });
            listData = response.lists;
            console.log(`Found ${listData.length} lists.`);
            await fetchBroadcasts(response.broadcasts, userToken);
        } catch (error) {
            console.error("Error fetching lists:", error);
        }
    }

    async function fetchBroadcasts(broadcasts, userToken) {
        console.log("Processing broadcasts...");
        
        // Extract dates from broadcasts to determine the sheet date
        const broadcastDates = broadcasts.map(b => new Date(b.date)).filter(date => !isNaN(date));
        const earliestDate = broadcastDates.length > 0 ? new Date(Math.min(...broadcastDates)) : new Date();
        const sheetDate = earliestDate.toISOString().slice(0, 10); // YYYY-MM-DD format
        
        console.log(`Broadcasts date range: ${broadcastDates.length > 0 ? 'earliest=' + sheetDate : 'no valid dates, using today'}`);
        
        // Check if this date's data has already been exported
        const alreadyExported = await checkIfDateAlreadyExported(sheetDate, userToken);
        if (alreadyExported) {
            const overwrite = confirm(`‚ö†Ô∏è Data for ${sheetDate} has already been exported to Google Sheets.\n\nDo you want to OVERWRITE the existing data?\n\nClick OK to overwrite, or Cancel to abort.`);
            if (!overwrite) {
                console.log("Export cancelled by user - data already exists for this date.");
                alert("Export cancelled. Data already exists for this date.");
                return;
            }
            console.log(`User chose to overwrite existing data for ${sheetDate}`);
        }
        
        const reportPromises = broadcasts.map(b => processBroadcast(b));
        totalReportsToProcess = reportPromises.length;
        await Promise.all(reportPromises);
        console.log("All broadcasts processed. Sending to Google Sheets.");
        await sendToGoogleSheets(userToken, sheetDate);
    }

    async function processBroadcast(broadcast) {
        if (processedLists.has(broadcast.id)) {
            console.log(`Skipping broadcast ${broadcast.id} as it's already been processed.`);
            return;
        }
        processedLists.add(broadcast.id);

        console.log(`Fetching report for broadcast ID: ${broadcast.id}`);
        const url = "https://api-prod-client.heymarket.com/v2/broadcast/report";
        const body = {
            list_id: broadcast.list_id,
            broadcast_id: broadcast.id,
            team_id: TEAM_ID
        };

        const brand = BRAND_MAP[broadcast.inbox_id] || 'Unknown Brand';

        try {
            const report = await fetchWithToken(url, { body: JSON.stringify(body) });
            const listInfo = listData.find(l => l.id === broadcast.list_id) || {};

            const contactPromises = report.contacts.map(contact => processContact(contact, brand, listInfo, broadcast.date));
            const results = await Promise.all(contactPromises);
            allData = allData.concat(results);
            reportsProcessed++;
            console.log(`Processed ${reportsProcessed} of ${totalReportsToProcess} reports.`);
        } catch (error) {
            console.error(`Error fetching report for broadcast ${broadcast.id}:`, error);
        }
    }

    async function processContact(contact, brand, listInfo, initialSendTime) {
        const number = formatPhoneNumber(contact.target);
        const contactInfo = listInfo.targets?.[contact.target] || {};
        const fname = contactInfo.f || "N/A";
        const lname = contactInfo.l || "N/A";
        const failed = contact.status === "failed" ? "X" : "";
        const hasResponse = contact.response_time !== "0001-01-01T00:00:00Z" ? "X" : "";
        const responseTime = hasResponse === "X" ? new Date(contact.response_time).toLocaleString('en-US', { timeZone: 'America/Chicago' }) : "";

        let conversation = [];
        if (hasResponse === "X" && contact.conversation_id) {
            conversation = await fetchConversation(contact.conversation_id);
        }

        const row = [
            brand,
            fname,
            lname,
            number,
            new Date(initialSendTime).toLocaleString('en-US', { timeZone: 'America/Chicago' }),
            failed,
            hasResponse,
            responseTime
        ];

        // Add conversation messages
        for (let i = 0; i < MAX_CONVERSATION_MESSAGES; i++) {
            row.push(conversation[i] || "");
        }

        return row;
    }

    async function fetchConversation(conversationId) {
        const url = "https://api-prod-client.heymarket.com/v2/messages/fetch";
        const body = {
            parent_id: conversationId,
            team_id: TEAM_ID,
            date: new Date().toISOString(),
            filter: "ALL",
            ascending: false,
            type: "messages"
        };
        const messages = [];

        try {
            const response = await fetchWithToken(url, { body: JSON.stringify(body) });
            const conversationMessages = response.messages
                .filter(m => m.type === 'text')
                .reverse()
                .map(m => {
                    const direction = m.sender === m.target ? "-> You" : "You ->";
                    return `${direction}: ${m.text}`;
                });
            messages.push(...conversationMessages);
        } catch (error) {
            console.error(`Error fetching conversation ${conversationId}:`, error);
        }
        return messages;
    }

    function createUI() {
        const button = document.createElement('button');
        
        // Update button text based on token status
        function updateButtonText() {
            if (SECURITY_TOKEN) {
                button.innerText = '‚úÖ Run Heymarket Scraper (Token Ready)';
                button.style.backgroundColor = '#28a745';
            } else {
                button.innerText = '‚è≥ Run Heymarket Scraper (Waiting for Token)';
                button.style.backgroundColor = '#ffc107';
            }
        }
        
        updateButtonText();
        
        // Check for token every 2 seconds and update button
        setInterval(updateButtonText, 2000);
        
        Object.assign(button.style, {
            position: 'fixed',
            bottom: '20px',
            right: '20px',
            zIndex: '10000',
            padding: '10px 20px',
            color: 'white',
            border: 'none',
            borderRadius: '5px',
            cursor: 'pointer',
            fontSize: '14px',
            fontWeight: 'bold'
        });

        button.addEventListener('click', () => {
            console.log("Starting Heymarket data scrape...");
            allData = []; // Clear previous data
            processedLists = new Set();
            reportsProcessed = 0;
            totalReportsToProcess = 0;
            fetchLists();
        });

        document.body.appendChild(button);
    }

    // Check if we're returning from authentication before creating UI
    if (!checkForAuthReturn()) {
        // Only create UI if we're not in the middle of auth flow
        createUI();
    }
})();